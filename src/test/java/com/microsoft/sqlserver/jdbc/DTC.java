package com.microsoft.sqlserver.jdbc;

import com.microsoft.sqlserver.testframework.AbstractTest;
import com.microsoft.sqlserver.testframework.Constants;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.junit.platform.runner.JUnitPlatform;
import org.junit.runner.RunWith;

import javax.sql.XAConnection;
import javax.transaction.xa.XAResource;
import javax.transaction.xa.Xid;
import java.net.Inet4Address;
import java.sql.Connection;
import java.util.Random;


@RunWith(JUnitPlatform.class)
@Tag(Constants.DTC)
public class DTC extends AbstractTest {
    @BeforeAll
    public static void setupTest() throws Exception {
        setConnection();
    }

    @Test
    public void testCstmtXpSqljdbcXaInit() throws Exception {
        SQLServerXADataSource XADataSource = new SQLServerXADataSource();
        XADataSource.setURL(connectionString);
        XAConnection XAConnection = XADataSource.getXAConnection();

        try (Connection con = XAConnection.getConnection()) {
            XAResource xaRes = null;
            Xid xid = null;
            xid = XidImpl.getUniqueXid(1);

            xaRes = XAConnection.getXAResource();
            xaRes.setTransactionTimeout(0);

            // Driver calls 'master..xp_sqljdbc_xa_init_ex(?,?,?)' internally as a cstmt.
            // Test that the registered out params are sent over the wire as non-PLP.
            // If the RPC params are sent as PLP, test will fail with the following error:
            // Failed to create the XA control connection. Error: "Cannot continue the execution because the
            // session is in the kill state.
            xaRes.start(xid, XAResource.TMNOFLAGS);
        }
    }

    static class XidImpl implements Xid {
        public int formatId;
        public byte[] gtrid;
        public byte[] bqual;
        static byte[] localIP = null;
        static int txnUniqueID = 0;

        public byte[] getGlobalTransactionId() {
            return gtrid;
        }

        public byte[] getBranchQualifier() {
            return bqual;
        }

        public int getFormatId() {
            return formatId;
        }

        XidImpl(int formatId, byte[] gtrid, byte[] bqual) {
            this.formatId = formatId;
            this.gtrid = gtrid;
            this.bqual = bqual;
        }

        static Xid getUniqueXid(int tid) {

            Random rnd = new Random(System.currentTimeMillis());
            txnUniqueID++;
            int txnUID = txnUniqueID;
            int tidID = tid;
            int randID = rnd.nextInt();
            byte[] gtrid = new byte[64];
            byte[] bqual = new byte[64];

            if (null == localIP) {
                try {
                    localIP = Inet4Address.getLocalHost().getAddress();
                } catch (Exception ex) {
                    localIP = new byte[] {0x01, 0x02, 0x03, 0x04};
                }
            }

            System.arraycopy(localIP, 0, gtrid, 0, 4);
            System.arraycopy(localIP, 0, bqual, 0, 4);

            // Bytes 4 -> 7 - unique transaction id.
            // Bytes 8 ->11 - thread id.
            // Bytes 12->15 - random number generated by using seed from current time in milliseconds.
            for (int i = 0; i <= 3; i++) {
                gtrid[i + 4] = (byte) (txnUID % 0x100);
                bqual[i + 4] = (byte) (txnUID % 0x100);
                txnUID >>= 8;
                gtrid[i + 8] = (byte) (tidID % 0x100);
                bqual[i + 8] = (byte) (tidID % 0x100);
                tidID >>= 8;
                gtrid[i + 12] = (byte) (randID % 0x100);
                bqual[i + 12] = (byte) (randID % 0x100);
                randID >>= 8;
            }
            return new DTC.XidImpl(0x1234, gtrid, bqual);
        }
    }
}
